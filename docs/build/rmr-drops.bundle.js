!function(n){var e={};function t(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return n[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}t.m=n,t.c=e,t.d=function(n,e,r){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:r})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var o in n)t.d(r,o,function(e){return n[e]}.bind(null,o));return r},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s="./src/scripts/build.js")}({"./node_modules/rmr-util/index.js":
/*!****************************************!*\
  !*** ./node_modules/rmr-util/index.js ***!
  \****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/* global */\n\n(function () {\n\n  'use strict';\n\n  var breakpoints = [{\n    name: 'xs',\n    value: 0\n  }, {\n    name: 'sm',\n    value: 576\n  }, {\n    name: 'md',\n    value: 768\n  }, {\n    name: 'lg',\n    value: 992\n  }, {\n    name: 'xl',\n    value: 1200\n  }],\n      easeInOutQuad = function easeInOutQuad(t) {\n    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n  };\n\n  /**\n   * rmr-util\n   *\n   * JS for your browser\n   *\n   *\n   *\n   */\n\n  var\n\n  /**\n   *\n   *\n   */\n  Base64 = {\n    _keyStr: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n    encode: function encode(e) {\n      var t = \"\";\n      var n = void 0,\n          r = void 0,\n          i = void 0,\n          s = void 0,\n          o = void 0,\n          u = void 0,\n          a = void 0;\n      var f = 0;\n      e = Base64._utf8_encode(e);\n      while (f < e.length) {\n        n = e.charCodeAt(f++);\n        r = e.charCodeAt(f++);\n        i = e.charCodeAt(f++);\n        s = n >> 2;\n        o = (n & 3) << 4 | r >> 4;\n        u = (r & 15) << 2 | i >> 6;\n        a = i & 63;\n        if (isNaN(r)) {\n          u = a = 64;\n        } else if (isNaN(i)) {\n          a = 64;\n        }\n        t = t + this._keyStr.charAt(s) + this._keyStr.charAt(o) + this._keyStr.charAt(u) + this._keyStr.charAt(a);\n      }\n      return t;\n    },\n\n    decode: function decode(e) {\n\n      var t = \"\";\n      var n = void 0,\n          r = void 0,\n          i = void 0,\n          s = void 0,\n          o = void 0,\n          u = void 0,\n          a = void 0;\n      var f = 0;\n\n      e = e.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n      while (f < e.length) {\n        s = this._keyStr.indexOf(e.charAt(f++));\n        o = this._keyStr.indexOf(e.charAt(f++));\n        u = this._keyStr.indexOf(e.charAt(f++));\n        a = this._keyStr.indexOf(e.charAt(f++));\n        n = s << 2 | o >> 4;\n        r = (o & 15) << 4 | u >> 2;\n        i = (u & 3) << 6 | a;\n        t = t + String.fromCharCode(n);\n        if (u !== 64) {\n          t = t + String.fromCharCode(r);\n        }\n        if (a !== 64) {\n          t = t + String.fromCharCode(i);\n        }\n      }\n      t = Base64._utf8_decode(t);\n      return t;\n    },\n    _utf8_encode: function _utf8_encode(e) {\n      e = e.replace(/\\r\\n/g, \"\\n\");\n      var t = \"\",\n          n = 0;\n      for (n = 0; n < e.length; n++) {\n        var r = e.charCodeAt(n);\n        if (r < 128) {\n          t += String.fromCharCode(r);\n        } else if (r > 127 && r < 2048) {\n          t += String.fromCharCode(r >> 6 | 192);\n          t += String.fromCharCode(r & 63 | 128);\n        } else {\n          t += String.fromCharCode(r >> 12 | 224);\n          t += String.fromCharCode(r >> 6 & 63 | 128);\n          t += String.fromCharCode(r & 63 | 128);\n        }\n      }\n      return t;\n    },\n\n    _utf8_decode: function _utf8_decode(e) {\n      var t = \"\",\n          n = 0,\n          r = 0,\n          c2 = 0,\n          c3 = 0;\n\n      while (n < e.length) {\n        r = e.charCodeAt(n);\n        if (r < 128) {\n          t += String.fromCharCode(r);\n          n++;\n        } else if (r > 191 && r < 224) {\n          c2 = e.charCodeAt(n + 1);\n          t += String.fromCharCode((r & 31) << 6 | c2 & 63);\n          n += 2;\n        } else {\n          c2 = e.charCodeAt(n + 1);\n          c3 = e.charCodeAt(n + 2);\n          t += String.fromCharCode((r & 15) << 12 | (c2 & 63) << 6 | c3 & 63);\n          n += 3;\n        }\n      }\n      return t;\n    }\n  },\n\n\n  /**\n   * Retrieve an element via query selector, or\n   *\n   * @param {Mixed} arg the element to retrieve, or null if no such element exists\n   * @return {Element} element corresponding to the selector (or null if none exists)\n   */\n  getElement = function getElement(arg, parent) {\n    if (typeof arg === 'string') {\n\n      var root = parent ? getElement(parent) : document;\n      if (!root) {\n        console.error('Invalid root for selector `' + arg + '`', parent);\n        return null;\n      }\n\n      return root.querySelector(arg);\n    } else if (arg instanceof HTMLElement) {\n      return arg;\n    }\n\n    return null;\n  },\n\n\n  /**\n   * Determine if a variable/object is an HTML element\n   *\n   * @param {Mixed}\n   * @return {Bool}\n   */\n  isAnElement = function isAnElement(arg) {\n    return arg instanceof HTMLElement;\n  },\n\n\n  /**\n   * Determine if a string is a valid internet URL\n   *\n   * @param {String} str - the string to be tested\n   * @return {Bool} - `true` of `false`\n   */\n  isURL = function isURL(str) {\n    // ???\n    return (/^(?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:[/?#]\\S*)?$/i.test(str)\n    );\n  },\n\n\n  /**\n    Format a latitude coordinate value into a human-friendly string\n     @param {Float} lat  value to be formatted\n    @return {String} formatted latitude string\n   */\n  formatLatitude = function formatLatitude(lat) {\n\n    var value = parseFloat(lat);\n\n    var dir = value < 0 ? 'S' : 'N';\n\n    var degrees = 0,\n        minutes = 0,\n        seconds = 0;\n\n    degrees = parseInt(value);\n    value = (value - degrees) * 60;\n\n    minutes = parseInt(value);\n    seconds = (value - minutes) * 60;\n\n    if (seconds < 0) {\n      seconds *= -1;\n    }\n\n    return Math.abs(degrees) + 'º' + Math.abs(minutes) + '’' + seconds.toFixed(2) + '”' + dir;\n  },\n\n\n  /**\n    Format a longitude coordinate value into a human-friendly string\n     @param {Float} lon  value to be formatted\n    @return {String} formatted longitude string\n   */\n  formatLongitude = function formatLongitude(lon) {\n\n    var value = parseFloat(lon);\n\n    var dir = value < 0 ? 'W' : 'E';\n\n    var degrees = 0,\n        minutes = 0,\n        seconds = 0;\n\n    degrees = parseInt(value);\n    value = (value - degrees) * 60;\n\n    minutes = parseInt(value);\n    seconds = (value - minutes) * 60;\n\n    return Math.abs(degrees) + 'º' + Math.abs(minutes) + '’' + Math.abs(seconds.toFixed(2)) + '”' + dir;\n  },\n\n\n  /**\n   * Determine if a node matches a provided selector\n   *\n   * @param {HTMLElement} node  the element to be tested\n   * @param {String} selector the selector string to test\n   * @return {Bool} `true` or `false`\n   */\n  selectorMatches = function selectorMatches(node, selector) {\n\n    var p = Element.prototype,\n        f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function matches() {\n      return [].indexOf.call(document.querySelectorAll(selector), this) !== -1;\n    };\n    try {\n      return f.call(node, selector);\n    } catch (e) {\n      return false;\n    }\n  },\n\n\n  /**\n   * Determine if we're in a touch-based browser (phone/tablet)\n   *\n   * @return {Bool} `true` or `false`\n   */\n  isTouch = function isTouch() {\n\n    if (typeof window === 'undefined' || typeof navigator === 'undefined') {\n      return false;\n    }\n    return typeof window.orientation !== 'undefined';\n  },\n\n\n  /**\n   * Determine if we're in Safari\n   *\n   * @return {Bool} `true` or `false`\n   */\n  isSafari = function isSafari() {\n\n    if (typeof window === 'undefined' || typeof navigator === 'undefined') {\n      return false;\n    }\n    return (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)\n    );\n  },\n\n\n  /**\n   * Determine if we're in Firefox\n   *\n   * @return {Bool} `true` or `false`\n   */\n  isFirefox = function isFirefox() {\n\n    if (typeof window === 'undefined' || typeof navigator === 'undefined') {\n      return false;\n    }\n    return navigator.userAgent.indexOf(\"Firefox\") > 0;\n  },\n\n\n  /**\n   * Is the browser capable of opening new windows/tabs with \"data:\" protocol\n   *\n   * @see https://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/GbVcuwg_QjM%5B1-25%5D\n   * @return {Bool} `true` if the browser opens `data:` URLs; `false` if not\n   */\n  opensData = function opensData() {\n    return isFirefox() || isSafari();\n  },\n\n\n  /**\n   * Retrieve an object containing browser/screen coordinates for a DOM element\n   *\n   * @param {Element} node the element whose coordinates should be retrieved\n   * @return {Object} An object containing { top : xx, left : xx, bottom: xx, right: xx, width: xx, height: xx }\n   */\n  getRect = function getRect(node) {\n\n    node = getElement(node);\n    if (!node) {\n      return { top: 0, left: 0, right: 0, width: 0, height: 0 };\n    }\n\n    var rect = node.getBoundingClientRect(),\n        ret = { top: rect.top, left: rect.left, bottom: rect.bottom, right: rect.right }; // create a new object that is not read-only\n\n    ret.top += window.pageYOffset;\n    ret.left += window.pageXOffset;\n\n    ret.bottom += window.pageYOffset;\n    ret.right += window.pageYOffset;\n\n    ret.width = rect.right - rect.left;\n    ret.height = rect.bottom - rect.top;\n\n    return ret;\n  },\n\n\n  /**\n   * Scroll to an element\n   *\n   * @param {Mixed} y - vertical offset to scroll to, or selector/node references for the Element to scroll to\n   * @param {Integer} duration - # of milliseconds animation should run\n   */\n  scrollTo = function scrollTo(y, duration) {\n\n    var timing = easeInOutQuad;\n    if (arguments.length === 1) {\n      duration = 200;\n    }\n\n    if (typeof y === 'string' || y instanceof Element) {\n      y = getRect(y).top;\n    }\n\n    var startingY = window.pageYOffset,\n        diff = y - startingY;\n\n    var start = performance.now();\n\n    // Bootstrap our animation - it will get called right before next frame shall be rendered.\n    window.requestAnimationFrame(function step(timestamp) {\n\n      var time = timestamp - start,\n          percent = Math.min(time / duration, 1);\n\n      window.scrollTo(0, startingY + diff * timing(percent));\n\n      // Proceed with animation as long as we wanted it to.\n      if (time < duration) {\n        window.requestAnimationFrame(step);\n      }\n    });\n  },\n      scrollNodeTo = function scrollNodeTo(element, to, duration, onDone) {\n\n    element = getElement(element);\n    var node = getElement(to, element);\n    if (node) {\n      to = relativePosition(node).top;\n    } else {\n      to = parseInt(to, 10);\n    }\n\n    if (!duration) {\n      duration = 200;\n    }\n\n    var start = element.scrollTop,\n        change = to - start,\n        startTime = performance.now(),\n        now = void 0,\n        elapsed = void 0,\n        t = void 0;\n\n    function animateScroll() {\n      now = performance.now();\n      elapsed = now - startTime;\n      t = elapsed / duration;\n\n      element.scrollTop = start + change * easeInOutQuad(t);\n      if (t < 1) {\n        window.requestAnimationFrame(animateScroll);\n      } else {\n        element.scrollTop = to;\n        onDone && onDone();\n      }\n    }\n\n    animateScroll();\n  },\n\n\n  /**\n   *\n   *\n   */\n  relativePosition = function relativePosition(node) {\n\n    node = getElement(node);\n\n    var pPos = node.parentNode.getBoundingClientRect(),\n        // parent pos\n    cPos = node.getBoundingClientRect(),\n        // target pos\n    pos = {};\n\n    pos.top = cPos.top - pPos.top + node.parentNode.scrollTop, pos.right = cPos.right - pPos.right, pos.bottom = cPos.bottom - pPos.bottom, pos.left = cPos.left - pPos.left;\n\n    return pos;\n  },\n\n\n  /*\n   * Generate a unique string suitable for id attributes\n   *\n   * @param basename (String)\n   * @return string\n   */\n  guid = function guid(basename) {\n    return (basename ? basename : 'rmr-guid-') + parseInt(Math.random() * 100, 10) + '-' + parseInt(Math.random() * 1000, 10);\n  },\n\n\n  /*\n   * Merge two objects into one, values in b take precedence over values in a\n   *\n   * @param a {Object}\n   * @param b {Object}\n    * @return Object\n   */\n  objectMerge = function objectMerge(a, b) {\n    var o = {};\n    var i = null;\n    for (i in a) {\n      if (objectHas(a, i)) {\n        o[i] = a[i];\n      }\n    }\n    if (!b) {\n      return o;\n    }\n    for (i in b) {\n      if (objectHas(b, i)) {\n        o[i] = b[i];\n      }\n    }\n    return o;\n  },\n\n\n  /**\n   * Convert an array-like thing (ex: NodeList or arguments object) into a proper array, or convert a scalar into a single-element array\n   *\n   * @param {Mixed} list an array-like thing or a scalar\n   * @return {Array} the param as an array\n   */\n  arr = function arr(list) {\n\n    var ret = [];\n    var i = 0;\n\n    if (list instanceof Array) {\n      return list;\n    }\n\n    if (typeof list.length !== 'number') {\n      return [list];\n    }\n\n    for (i = 0; i < list.length; i++) {\n      if (objectHas(list, i)) {\n        ret.push(list[i]);\n      }\n    }\n\n    return ret;\n  },\n\n\n  /**\n   * Remove an object from an array\n   *\n   * @param {Array} array containing object to be removed\n   * @param {Any} item to be removed\n   * @return {Array} array for chaining\n   */\n  arrayRemove = function arrayRemove(array, item) {\n    return arr(array).filter(function (e) {\n      return e !== item;\n    });\n  },\n\n\n  /**\n   * Return the index of an item in an array\n   *\n   * @param {Array} list that should be searched\n   * @param {Function} func comparator function that takes on argument\n   * @return {Integer} index of the item in the array, or -1 if it doesn't exist\n   */\n  arrayFind = function arrayFind(list, func) {\n\n    var array = arr(list);\n\n    if (typeof func !== 'function') {\n\n      var target = func,\n          lookup = function lookup(param) {\n\n        if ((typeof param === 'undefined' ? 'undefined' : _typeof(param)) === 'object' && objectHas(param, 'id')) {\n          if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && objectHas(target, 'id')) {\n            return param.id === target.id;\n          }\n          return param.id === target;\n        }\n\n        return param === target;\n      };\n      func = lookup;\n    }\n    for (var i in array) {\n      if (!objectHas(array, i)) {\n        continue;\n      }\n\n      if (array[i] === func || func(array[i])) {\n        return parseInt(i, 10);\n      }\n    }\n    return -1;\n  },\n\n\n  /**\n   * Shift the objects within an array so that a given item is first\n   *\n   * @param {Array} array containing object to be removed\n   * @param {Any} item to be made the first\n   * @return {Array} array for chaining\n   */\n  arrayReorder = function arrayReorder(array, item) {\n\n    var list = arr(array),\n        reordered = [];\n\n    var index = arrayFind(list, item);\n    if (index === -1) {\n      return list;\n    }\n\n    reordered.push(list[index]);\n\n    for (var i = index + 1; i < list.length; i++) {\n      reordered.push(array[i]);\n    }\n\n    for (var _i = 0; _i < index; _i++) {\n      reordered.push(array[_i]);\n    }\n\n    return reordered;\n  },\n\n\n  /**\n   * Remove all children from a node (optionally matching a selector)\n   *\n   * @param {Mixed} arg - node or selector whose children should be removed\n   * @param {String,optional} selector - query selector that children must match in order to be removed\n   * @return {HTMLElement} - for chaining\n   */\n  pruneElement = function pruneElement(arg, selector) {\n\n    var node = getElement(arg);\n    if (!node) {\n      return null;\n    }\n    if (selector) {\n      var n = arr(arg.querySelectorAll(selector));\n      for (var i = 0; i < n.length; i++) {\n        removeNode(n[i]);\n      }\n    } else {\n      while (node.firstChild) {\n        node.removeChild(node.firstChild);\n      }\n    }\n\n    return node;\n  },\n\n\n  /**\n   * Retrieve an element via query selector\n   *\n   * @param {Mixed} arg selector, or an array of elements to attach\n   * @param {Mixed,optional} scope the parent node\n   * @return {[Element]} array of elements\n   */\n  getElements = function getElements(arg, scope) {\n\n    if (!scope) {\n      scope = document;\n    } else {\n      scope = getElement(scope);\n    }\n\n    if (typeof arg === 'string') {\n      return arr(scope.querySelectorAll(arg));\n    }\n\n    return arr(arg);\n  },\n\n\n  /*\n   * Create an element with a set of attributes/values\n   *\n   * @param type (String)\n   * @param attrs {Object}\n   *\n   * @return HTMLElement\n   */\n  makeElement = function makeElement(type, attrs) {\n\n    var n = document.createElement(type);\n\n    for (var i in attrs) {\n      if (objectHas(attrs, i) && attrs[i]) {\n        n.setAttribute(i, attrs[i]);\n      }\n    }\n    return n;\n  },\n\n\n  /**\n   * Make loader\n   *\n   * @return {String} SVG element\n   */\n  loader = function loader() {\n\n    /*\n        const svg = makeElement('svg', {\n          version: '1.1',\n          class: 'rmr-loader',\n          xmlns: 'http://www.w3.org/2000/svg',\n          'xmlns:xlink': 'http://www.w3.org/1999/xlink',\n          x: '0px',\n          y: '0px',\n          width: '40px',\n          height: '40px',\n          viewBox: '0 0 40 40',\n          'enable-background': 'new 0 0 40 40',\n          'xml:space': 'preserve'\n        });\n    \n        svg.innerHTML =\n        '<path opacity=\"0.2\" fill=\"#000\" d=\"M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946 s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634 c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z\"></path>' +\n        '<path fill=\"#000\" d=\"M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0 C22.32,8.481,24.301,9.057,26.013,10.047z\">' +\n        '<animateTransform attributeType=\"xml\" attributeName=\"transform\" type=\"rotate\" from=\"0 20 20\" to=\"360 20 20\" dur=\"0.8s\" repeatCount=\"indefinite\"></animateTransform>' +\n        '</path>';\n    */\n\n    return '<svg version=\"1.1\" class=\"rmr-loader\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"40px\" height=\"40px\" viewBox=\"0 0 40 40\" enable-background=\"new 0 0 40 40\" xml:space=\"preserve\">' + '<path opacity=\"0.2\" fill=\"#000\" d=\"M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946 s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634 c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z\"></path>' + '<path fill=\"#000\" d=\"M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0 C22.32,8.481,24.301,9.057,26.013,10.047z\">' + '<animateTransform attributeType=\"xml\" attributeName=\"transform\" type=\"rotate\" from=\"0 20 20\" to=\"360 20 20\" dur=\"0.8s\" repeatCount=\"indefinite\"></animateTransform>' + '</path>' + '</svg>';\n\n    //    return svg;\n  },\n\n\n  /**\n   * Localize a string\n   *\n   * {\n   *   'en' : {\n   *      'key' : 'neighbor'\n   *    },\n   *    'en-ca' : {\n   *      'key' : 'neighbour'\n   *    }\n   *  }\n   *\n   * @param {Object} lookup dictionary\n   * @param {String} key the to localize\n   * @return {String} string\n   */\n  localize = function localize(lookup, key) {\n\n    if (typeof navigator === 'undefined') {\n      return key;\n    }\n\n    var i = void 0,\n        lang = void 0;\n\n    for (i in navigator.languages) {\n      if (!objectHas(navigator.languages, i)) {\n        continue;\n      }\n      lang = navigator.languages[i].toLowerCase();\n      if (objectHas(lookup, lang) && objectHas(lookup[lang], key)) {\n        return lookup[lang][key];\n      }\n    }\n    console.warn('No localization for ' + key);\n    return key;\n  },\n\n\n  /**\n   * Apply styles to a node\n   *\n   * @param {HTMLElement} node that should have styles applied\n   * @param {Object} styles key/value pairs for styles and values\n   * @return {Element} node\n   */\n  setStyles = function setStyles(node, styles) {\n\n    node = getElement(node);\n    if (!node) {\n      return false;\n    }\n\n    for (var i in styles) {\n      if (objectHas(styles, i) && styles[i]) {\n        node.style[i] = styles[i];\n      }\n    }\n\n    return node;\n  },\n\n\n  /**\n   * Apply attributes to a node\n   *\n   * @param {HTMLElement} node that should have styles applied\n   * @param {Object} styles key/value pairs for styles and values\n   * @return {Element} node\n   */\n  setAttributes = function setAttributes(node, attrs) {\n\n    node = getElement(node);\n    if (!node) {\n      return false;\n    }\n\n    for (var i in attrs) {\n      if (objectHas(attrs, i) && attrs[i]) {\n        if (attrs[i]) {\n          node.setAttribute([i], attrs[i]);\n        } else {\n          node.removeAttribute([i], attrs[i]);\n        }\n      }\n    }\n\n    return node;\n  },\n\n\n  /**\n   * Build a query string from an object\n   *\n   * @param {Object} obj the object to be passed via URL\n   * @return {String} str query string corresponding to the object\n   */\n  queryString = function queryString(obj) {\n\n    if (Object.keys(obj).length === 0) {\n      return '';\n    }\n\n    return Object.keys(obj).reduce(function (a, k) {\n      a.push(k + '=' + encodeURIComponent(obj[k]));\n      return a;\n    }, []).join('&');\n  },\n\n\n  /**\n   * Return an array of all keys in an object (polyfill for Object.keys)\n   *\n   * @param {Object} obj object whose keys should be retrieved\n   * @return {Array} key list\n   */\n  objectKeys = function objectKeys(obj) {\n\n    if (typeof Object !== \"undefined\" && typeof Object.keys !== \"undefined\") {\n      return Object.keys(obj);\n    }\n\n    var a = [];\n    for (var i in obj) {\n      if (objectHas(obj, i)) {\n        a.push(i);\n      }\n    }\n\n    return a;\n  },\n\n\n  /**\n   * Retrieve (potentially nested) value from object\n   *\n   * @param {Object} object - target object to be inspected\n   * @param {String} path - nested paths\n   * @param {Mixed} fallback - value to return if path not found (default to `null`)\n   * @return {Mixed} - value found at path, or `null` if no such path exists\n   */\n  objectGet = function objectGet(object, path, fallback) {\n\n    var bits = path.split('.');\n    var target = object;\n\n    for (var i = 0; i < bits.length; i++) {\n      if (!objectHas(target, bits[i])) {\n        return fallback ? fallback : null;\n      }\n      target = target[bits[i]];\n    }\n\n    return target;\n  },\n      objectHas = function objectHas(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n  },\n\n\n  /**\n   * Generate an object containing keys/values corresponding to form elements\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/FormData/Using_FormData_Objects\n   * @param {Element} form element\n   * @return {Object} the key/value pairs for the form\n   */\n  objectFromForm = function objectFromForm(form) {\n\n    form = getElement(form);\n    if (!form) {\n      return {};\n    }\n\n    if (typeof FormData !== 'undefined') {\n      //      const f = new FormData(form);\n      //      console.log(f);\n      //      return f;\n    }\n\n    var inputs = form.querySelectorAll('select,input,textarea'),\n        params = {};\n\n    for (var i in inputs) {\n      if (!objectHas(inputs, i)) {\n        continue;\n      }\n      var name = inputs[i].getAttribute('name'),\n          type = inputs[i].type ? inputs[i].type : 'text';\n\n      if (inputs[i].hasAttribute('disabled')) {\n        continue;\n      }\n\n      if (type === 'radio' || type === 'checkbox') {\n        if (inputs[i].checked) {\n          params[name] = inputs[i].value;\n        }\n      } else {\n        params[name] = inputs[i].value;\n      }\n    }\n\n    return params;\n  },\n\n\n  /**\n   * Add event listener to >= 1 node\n   *\n   * @param {String} selector to match nodes\n   * @param {String} eventName the event which should be listened for\n   * @param {Function} func the method to invoke when eventName occurs\n   */\n  addListener = function addListener(selector, eventName, func) {\n    var nodes = getElements(selector);\n    var i = 0;\n\n    for (i in nodes) {\n      if (objectHas(nodes, i)) {\n        nodes[i].addEventListener(eventName, func);\n      }\n    }\n  },\n\n\n  /**\n   * Get a node's ancestor\n   *\n   * @param {Element} node starting point of search\n   * @param {String} ancestor the selector for the ancestor we're looking for\n   * @param {Bool} includeSelf optionally include starting point in search\n   * @return {Element} or `null` if no such ancestor exists\n   */\n  ancestor = function ancestor(node, _ancestor, includeSelf) {\n\n    node = getElement(node);\n    if (!node) {\n      return null;\n    }\n\n    if (includeSelf && selectorMatches(node, _ancestor)) {\n      return node;\n    }\n\n    var parent = node;\n\n    if (!parent.parentNode) {\n      return null;\n    }\n\n    while ((parent = parent.parentNode) !== null) {\n\n      //       if (! parent instanceof Element) {\n      //         return null;\n      //       }\n\n      if (selectorMatches(parent, _ancestor)) {\n        return parent;\n      }\n    }\n\n    return null;\n  },\n\n\n  /**\n   * Remove a DOM node from the document\n   *\n   * @param {Element} node the node to be removed\n   * @return {Bool} `true` if removed'; `false` if the node doesn't exist\n   */\n  removeNode = function removeNode(node) {\n\n    node = getElement(node);\n    if (!node) {\n      return false;\n    }\n\n    node.parentNode.removeChild(node);\n\n    return true;\n  },\n\n\n  /**\n   * Make an XHR request\n   *\n   * {\n   *   form: {selector} - form element to serialize and submit via xhr\n   *   url: '{string}',\n   *   method: '{GET|POST}',\n   *   headers: [],\n   *   params: {}\n   * }\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n   * @param {Object} config url, method, params, form\n   * @param {Function} handler invoked on completion\n   * @return {XMLHttpRequest} object making the request\n   */\n  xhrRequest = function xhrRequest(config, handler) {\n\n    if (typeof XMLHttpRequest === 'undefined') {\n      return null;\n    }\n\n    var defaults = {\n      form: null,\n      url: '/',\n      headers: {},\n      method: 'get',\n      params: {}\n    };\n\n    config = objectMerge(defaults, config);\n\n    if (config.form) {\n      config.form = getElement(config.form);\n      config.url = config.form.getAttribute('action'), config.method = config.form.getAttribute('method') ? config.form.getAttribute('method') : 'get', config.params = objectFromForm(config.form);\n    }\n\n    var xhttp = new XMLHttpRequest();\n    xhttp.onreadystatechange = function () {\n\n      if (this.readyState === 4) {\n        if (handler) {\n          handler(xhttp);\n        }\n      }\n    };\n\n    var url = config.url,\n        params = '';\n\n    if (config.form) {\n      var type = config.form.getAttribute('enctype');\n      if (type) {\n        config.headers['Content-Type'] = type;\n      }\n    }\n\n    if (config.method.toUpperCase() === 'GET') {\n      url = Object.keys(config.params).length > 0 ? url + '?' + queryString(config.params) : url;\n    } else {\n      // post\n      params = queryString(config.params);\n      config.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n    }\n\n    config.headers['X-Requested-With'] = 'XMLHttpRequest';\n\n    xhttp.open(config.method, url, true);\n\n    for (var h in config.headers) {\n      if (objectHas(config.headers, h)) {\n        xhttp.setRequestHeader(h, config.headers[h]);\n      }\n    }\n\n    xhttp.send(params);\n\n    return xhttp;\n  },\n\n\n  /**\n   *\n   *\n   *\n   dataFromNode = function(node) {\n   },\n   */\n\n  /**\n   * Retrieve the last non-empty element of an array\n   *\n   * @param {Array} list - array to be iterated through\n   * @param {Function} func (optional) function used to evaluate items in the array\n   * @return {Mixed} the last non-empty value in the array (or `null` if no such value exists)\n   */\n  lastValue = function lastValue(list, func) {\n\n    list = arr(list);\n\n    var i = list.length - 1;\n    while (i >= 0) {\n      if (func ? func(list[i]) : list[i]) {\n        return list[i];\n      }\n      i--;\n    }\n\n    return null;\n  };\n\n  var subs = {};\n\n  module.exports = {\n\n    Base64: Base64,\n\n    Tools: {\n      externalLinks: function externalLinks(root) {\n        var parent = root ? getElement(root) : document.body;\n        if (!parent) {\n          console.error('Node doesn\\'t exist RMR.Tools.externalLinks', root);\n          return;\n        }\n\n        var links = parent.querySelectorAll('a'),\n            location = document.location;\n\n        for (var i = 0; i < links.length; i++) {\n          var a = links[i];\n          if (a.protocol === 'mailto:') {\n            continue;\n          }\n          //          console.log(a.host, location.host)\n          if (a.host !== location.host) {\n            a.classList.add('rmr-external');\n            a.setAttribute('target', '_blank');\n          }\n        }\n      }\n    },\n\n    // document.body.addEventListener('keyup', function(e){ console.log(e.keyCode); });\n    Keyboard: {\n      next: 39,\n      previous: 37,\n      up: 38,\n      down: 40,\n      escape: 27,\n      enter: 13,\n      space: 32,\n      digits: [49, 50, 51, 52, 53, 54, 55, 56, 57, 48], // treat 0 zero as the last ordinal\n\n      /**\n       * Determine if a keyboardEvent has a modifier key associated\n       *\n       * @param {KeyboardEvent} e the event\n       * @return {Bool} `true` if event has a modifier key attached (control, shift, command, alt, etc.); `false` if not\n       */\n      hasModifier: function hasModifier(e) {\n        return e.metaKey || e.altKey || e.ctrlKey || e.shiftKey;\n      },\n\n      /**\n       * Return the ordinal (0-9) of a keypress; -1 if N/A, key \"0\" return ordinal 9\n       *\n       * @param {Integer|Event} keyCode either the key code or the window event for a `keypress`\n       * @return {Integer} ordinal for the key, or -1 if N/A\n       */\n      ordinal: function ordinal(keyCode) {\n\n        keyCode = parseInt(typeof keyCode !== 'number' ? keyCode.keyCode : keyCode, 10);\n\n        if (keyCode === 48) {\n          return 9;\n        } else if (keyCode >= 49 && keyCode <= 57) {\n          return keyCode - 49;\n        }\n\n        return -1;\n      }\n    },\n\n    Date: {\n\n      /**\n       * Convert a Date instance to RFC 3339 format, ex: `2019-01-17T17:55:48Z`\n       *\n       * @param {Date} date to be formatted, optional\n       * @return {String} Date in RFC 3339 format\n       * @see https://tools.ietf.org/html/rfc3339\n       */\n      toRFC3339: function toRFC3339(date) {\n\n        if (!date) {\n          date = new Date();\n        }\n\n        var pad = function pad(n) {\n          return n < 10 ? '0' + n : n;\n        };\n\n        return date.getUTCFullYear() + '-' + pad(date.getUTCMonth() + 1) + '-' + pad(date.getUTCDate()) + 'T' + pad(date.getUTCHours()) + ':' + pad(date.getUTCMinutes()) + ':' + pad(date.getUTCSeconds()) + 'Z';\n      },\n\n      fromRFC3339: function fromRFC3339(dString) {\n\n        if (!dString) {\n          return null;\n        }\n\n        return new Date(dString);\n        /*\n                const ret = new Date();\n        \n                let utcOffset, offsetSplitChar;\n                let offsetMultiplier = 1;\n                const dateTime = dString.split(\"T\");\n                const date = dateTime[0].split(\"-\");\n                const time = dateTime[1].split(\":\");\n                const offsetField = time[time.length - 1];\n                let offsetString;\n        \n                const offsetFieldIdentifier = offsetField.charAt(offsetField.length - 1);\n                if (offsetFieldIdentifier === \"Z\") {\n                    utcOffset = 0;\n                    time[time.length - 1] = offsetField.substr(0, offsetField.length - 2);\n                } else {\n                    if (offsetField[offsetField.length - 1].indexOf(\"+\") !== -1) {\n                        offsetSplitChar = \"+\";\n                        offsetMultiplier = 1;\n                    } else {\n                        offsetSplitChar = \"-\";\n                        offsetMultiplier = -1;\n                    }\n                    offsetString = offsetField.split(offsetSplitChar);\n                    time[time.length - 1] === offsetString[0];\n                    offsetString = offsetString[1].split(\":\");\n                    utcOffset = (offsetString[0] * 60) + offsetString[1];\n                    utcOffset = utcOffset * 60 * 1000;\n                }\n        \n                ret.setTime(Date.UTC(date[0], date[1] - 1, date[2], time[0], time[1], time[2]) + (utcOffset * offsetMultiplier));\n                return ret;\n        */\n      }\n    },\n\n    OS: {\n      isApple: function isApple() {\n        var agent = window.navigator.userAgent;\n        return agent.match('iPhone;') || agent.match('iPad;') || agent.match('iPod;') || agent.match('Mac OS X');\n      }\n    },\n    Browser: {\n      isTouch: isTouch,\n      isDark: function isDark() {\n        return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;\n      },\n      isSafari: isSafari,\n      isFirefox: isFirefox,\n      scrollTo: scrollTo,\n      opensData: opensData,\n      Breakpoint: {\n\n        /**\n         \n         */\n        up: function up(w) {\n          var arg = parseInt(w ? w : window.innerWidth, 10);\n\n          for (var i in breakpoints) {\n            if (breakpoints[i].value > arg) {\n              return breakpoints[i].name;\n            }\n          }\n          return null;\n        },\n        down: function down(w) {\n          var arg = parseInt(w ? w : window.innerWidth, 10),\n              reversed = Array.from(breakpoints).reverse();\n\n          for (var i in reversed) {\n            if (arg > reversed[i].value) {\n              return reversed[i].name;\n            }\n          }\n          return 'xs';\n        },\n        all: function all() {\n          var obj = {};\n          breakpoints.map(function (o) {\n            obj[o.name] = o.value;\n          });\n\n          return obj;\n        }\n      }\n    },\n    String: {\n      isURL: isURL,\n      guid: guid,\n      localize: localize\n    },\n    Array: {\n      coerce: arr,\n      last: lastValue,\n      remove: arrayRemove,\n      find: arrayFind,\n      reorder: arrayReorder\n    },\n    Notify: {\n      post: function post(name, obj) {\n\n        var special = '*';\n\n        if (objectHas(subs, special)) {\n          for (var i in subs[special]) {\n            if (!objectHas(subs[special], i)) {\n              continue;\n            }\n            subs[special][i](obj);\n          }\n        }\n\n        if (!objectHas(subs, name)) {\n          return;\n        }\n\n        for (var _i2 in subs[name]) {\n          if (!objectHas(subs[name], _i2)) {\n            continue;\n          }\n          subs[name][_i2](obj);\n        }\n      },\n      subscribe: function subscribe(name, f) {\n        if (!objectHas(subs, name)) {\n          subs[name] = [];\n        }\n        subs[name].push(f);\n      }\n    },\n    Object: {\n      keys: objectKeys,\n      merge: objectMerge,\n      value: objectGet,\n      fromForm: objectFromForm,\n      queryString: queryString,\n      has: objectHas\n    },\n    XHR: {\n      request: xhrRequest\n    },\n    Timing: {\n      easeInOut: easeInOutQuad\n    },\n    Map: {\n      formatLatitude: formatLatitude,\n      formatLongitude: formatLongitude\n    },\n    Node: {\n      isa: isAnElement,\n      ancestor: ancestor,\n      matches: selectorMatches,\n      remove: removeNode,\n      loader: loader,\n      get: getElement,\n      getAll: getElements,\n      prune: pruneElement,\n      listen: addListener,\n      create: makeElement,\n      getRect: getRect,\n      setStyles: setStyles,\n      setAttributes: setAttributes,\n      scrollTo: scrollNodeTo,\n      relaivePosition: relativePosition\n    }\n  };\n\n  if (typeof window !== 'undefined') {\n\n    window.addEventListener('load', function () {\n      document.body.classList.add('rmr-load');\n    });\n\n    window.document.addEventListener('DOMContentLoaded', function () {\n      document.body.classList.remove('rmr-nojs');\n      document.body.classList.add('rmr-js');\n\n      if (isTouch()) {\n        document.body.classList.add('rmr-touch');\n\n        var resizer = function resizer() {\n\n          var body = document.body,\n              cls = window.innerWidth > window.innerHeight ? 'rmr-landscape' : 'rmr-portrait';\n\n          body.classList.remove('rmr-landscape');\n          body.classList.remove('rmr-portrait');\n\n          body.classList.add(cls);\n        };\n\n        window.addEventListener('orientationchange', function () {\n          resizer();\n        });\n\n        resizer();\n      } else {\n        var body = document.body,\n            hover = 'rmr-hover',\n            out = 'rmr-nohover';\n\n        body.addEventListener('mouseenter', function () {\n          body.classList.add(hover);\n          body.classList.remove(out);\n        });\n\n        body.addEventListener('mouseleave', function () {\n          body.classList.remove(hover);\n          body.classList.add(out);\n        });\n      }\n    });\n  }\n\n  /*\n    (function() {\n      var elements = ['section', 'article', 'aside', 'header', 'footer', 'nav', 'figure', 'figcaption', 'time', 'mark', 'main'];\n      for (const i in elements) {\n        if (elements.hasOwnProperty(i)) {\n          console.log(elements[i]);\n          document.createElement(elements[i]);\n        }\n      }\n    })();\n  */\n})();\n\n//# sourceURL=webpack:///./node_modules/rmr-util/index.js?")},"./src/scripts/build.js":
/*!******************************!*\
  !*** ./src/scripts/build.js ***!
  \******************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\n/* global require, module, console, Promise */\n\n(function () {\n\n  'use strict';\n\n  window.Drops = __webpack_require__(/*! ./rmr-drops.js */ \"./src/scripts/rmr-drops.js\");\n})();\n\n//# sourceURL=webpack:///./src/scripts/build.js?")},"./src/scripts/rmr-drops.js":
/*!**********************************!*\
  !*** ./src/scripts/rmr-drops.js ***!
  \**********************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\n/* global  */\n\n/*\n * rmr-drops\n * © 2020 David Miller\n * https://readmeansrun.com\n */\n\n(function () {\n\n  'use strict';\n\n  var RMR = __webpack_require__(/*! rmr-util */ \"./node_modules/rmr-util/index.js\"),\n\n\n  // being viewed on a touch device?\n  TOUCH = RMR.Browser.isTouch(),\n\n\n  // attributes used throughout the widget\n  ATTRS = {\n    drops: 'rmr-drops',\n    arrow: 'rmr-arrow',\n    open: 'rmr-open',\n    show: 'rmr-show'\n  };\n\n  //   console.log(TOUCH);\n\n  /**\n    \n     @param options {Object} - \n   \n   */\n  var Drops = function Drops(options) {\n\n    if (!parseInt(options.delay, 10)) {\n      options.delay = 0;\n    }\n    options.offset = parseInt(options.offset, 10) > 0 ? parseInt(options.offset, 10) : 0;\n    options.arrow = parseInt(options.arrow, 10) > 0 ? parseInt(options.arrow, 10) : 0;\n\n    var uls = options.node ? RMR.Node.getAll(options.node) : RMR.Node.getAll('ul.' + ATTRS.drops),\n\n\n    // hash of all timeout references \n    timeouts = {},\n\n\n    // event handler for li > dl > dt > a\n    clicker = function clicker(e) {\n      var li = RMR.Node.ancestor(e.target, 'li', false),\n          isOpen = li.classList.contains(ATTRS.open);\n\n      if (TOUCH && !isOpen || options.hover || !isOpen) {\n        e.preventDefault();\n        on(e);\n      }\n    },\n\n\n    // event handler to open a dropdown \n    on = function on(e) {\n      var li = RMR.Node.ancestor(e.target, 'li', true);\n\n      // remove timeouts for hiding this dropdown\n      if (RMR.Object.has(timeouts, li.getAttribute('id'))) {\n        window.clearTimeout(timeouts[li.getAttribute('id')]);\n        delete timeouts[li.getAttribute('id')];\n      }\n\n      // no more work necessary\n      if (li.classList.contains(ATTRS.open) && li.classList.contains(ATTRS.show)) {\n        return;\n      }\n\n      li.classList.add(ATTRS.open);\n      window.setTimeout(function () {\n        li.classList.add(ATTRS.show);\n      }, !options.hover || TOUCH || e.type === 'focus' ? 0 : 100);\n\n      var drop = li.querySelector(':scope dd'),\n          target = li.querySelector(':scope dt');\n\n      // no dropdown \n      if (!target) {\n        return;\n      }\n\n      var origin = RMR.Node.getRect(target),\n          targetStyle = window.getComputedStyle(target),\n          arrowColor = window.getComputedStyle(drop.querySelector(':scope > div')).backgroundColor;\n\n      var arrow = void 0;\n      if (options.arrow) {\n        RMR.Node.prune(drop, 'b.' + ATTRS.arrow);\n        arrow = RMR.Node.create('b', { class: ATTRS.arrow });\n        RMR.Node.setStyles(arrow, {\n          borderBottomColor: arrowColor,\n          borderLeftWidth: options.arrow + 'px',\n          borderRightWidth: options.arrow + 'px',\n          borderBottomWidth: options.arrow + 'px'\n        });\n\n        drop.insertBefore(arrow, drop.firstChild);\n        arrow.style.marginLeft = parseInt(targetStyle.width, 10) / 2 - options.arrow / 2 + 'px';\n      }\n\n      var rect = RMR.Node.getRect(drop);\n\n      // place the dropdown `offset` px away from its parent\n      drop.style.top = parseInt(targetStyle.height, 10) + options.offset + 'px';\n      rect = RMR.Node.getRect(drop);\n\n      // position centered \n      if (options.center) {\n        drop.style.left = parseInt((origin.width - rect.width) / 2, 10) + 'px';\n        rect = RMR.Node.getRect(drop);\n      }\n\n      // is the dropdown clipped by the right edge of the window?\n      if (rect.right >= window.innerWidth) {\n        drop.style.left = window.innerWidth - rect.right - 15 + 'px';\n        rect = RMR.Node.getRect(drop);\n      }\n\n      // is the dropdown clipped by the left edge of the window?\n      if (rect.left < 0) {\n        drop.style.left = 10 + 'px';\n        rect = RMR.Node.getRect(drop);\n      }\n\n      // is the dropdown clipped by the bottom?\n      if (rect.bottom > window.innerHeight) {\n        if (options.arrow) {\n          RMR.Node.remove(arrow);\n          arrow.classList.add('rmr-bottom');\n          RMR.Node.setStyles(arrow, {\n            borderTopColor: arrowColor,\n            borderBottomColor: 'transparent',\n            borderTopWidth: options.arrow,\n            borderBottomWidth: '0px'\n          });\n          drop.appendChild(arrow);\n        }\n        rect = RMR.Node.getRect(drop);\n        drop.style.top = 0 - rect.height - options.offset + 'px';\n      }\n\n      // loop through all other dropdowns in this group and hide them \n      var lis = RMR.Node.ancestor(li, 'ul.' + ATTRS.drops).querySelectorAll(':scope > li');\n      for (var i in lis) {\n        if (!RMR.Object.has(lis, i) || lis[i].getAttribute('id') == li.getAttribute('id')) {\n          continue;\n        }\n        hide(lis[i]);\n      }\n    },\n\n\n    // force a dropdown to close\n    hide = function hide(target) {\n      target.classList.remove(ATTRS.open);\n      target.classList.remove(ATTRS.show);\n      window.clearTimeout(timeouts[target.getAttribute('id')]);\n      delete timeouts[target.getAttribute('id')];\n    },\n\n\n    // event handler to close a dropdown after the designated period of time \n    off = function off(e) {\n      var li = RMR.Node.ancestor(e.target, 'li', true);\n      timeouts[li.getAttribute('id')] = window.setTimeout(function () {\n        hide(li);\n      }, options.delay);\n    };\n\n    // sanity check before proceeding with initialization\n    if (uls.length === 0) {\n      console.error('No rmr-drops to init');\n      return;\n    }\n\n    var _loop = function _loop(i) {\n      if (!RMR.Object.has(uls, i)) {\n        return 'continue';\n      }\n\n      var ul = uls[i],\n          lis = ul.querySelectorAll(':scope > li');\n\n      // add event listener to dismiss popovers when document.body is clicked on\n      if (!options.hover || TOUCH) {\n        document.body.addEventListener('click', function (e) {\n          var ul = RMR.Node.ancestor(e.target, 'ul.' + ATTRS.drops, false);\n          if (!ul) {\n            for (var _i in lis) {\n              if (!RMR.Object.has(lis, _i)) {\n                continue;\n              }\n              hide(lis[_i]);\n            }\n          }\n        });\n      }\n\n      // all \n      for (var j in lis) {\n        if (!RMR.Object.has(lis, j)) {\n          continue;\n        }\n        var li = lis[j];\n\n        // ensure li has unique id\n        if (!li.getAttribute('id')) {\n          li.setAttribute('id', RMR.String.guid());\n        }\n\n        // add listeners to all links in the dropdown list to keep dropdown open \n        var links = li.querySelectorAll('dd a');\n        for (var _j in links) {\n          if (!RMR.Object.has(links, _j)) {\n            continue;\n          }\n\n          links[_j].addEventListener('focus', function (e) {\n            var target = RMR.Node.ancestor(e.target.parentNode.parentNode, 'li', false);\n            on({ target: target });\n          });\n\n          links[_j].addEventListener('blur', function (e) {\n            var target = RMR.Node.ancestor(e.target.parentNode.parentNode, 'li', false);\n            off({ target: target });\n          });\n        }\n\n        var a = li.querySelector(':scope dt a');\n        if (options.hover) {\n          li.addEventListener('mouseenter', on);\n          li.addEventListener('mouseleave', off);\n        } else {\n          if (a) {\n            // if the target is clicked and its dropdown is NOT open (or we're on a touch device where there is no hover event)\n            a.addEventListener('click', clicker);\n          }\n        }\n        // add listeners to target link\n        if (a) {\n          a.addEventListener('focus', function (e) {\n            window.setTimeout(function () {\n              on(e);\n            }, 100); // delay for all browsers\n          });\n          a.addEventListener('blur', off);\n        }\n      }\n    };\n\n    for (var i in uls) {\n      var _ret = _loop(i);\n\n      if (_ret === 'continue') continue;\n    }\n\n    return {\n      drop: function drop(arg) {\n        var n = RMR.Node.get(arg);\n        if (!n) {\n          console.error('No dropdown exists', arg);\n          return;\n        }\n        on({ target: n });\n      }\n    };\n  };\n\n  window.RMR = RMR;\n  module.exports = Drops;\n})();\n\n//# sourceURL=webpack:///./src/scripts/rmr-drops.js?")}});